<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>树的前中序遍历迭代法实现</title>
      <link href="/2022/05/28/shu-de-qian-zhong-xu-bian-li-die-dai-fa-shi-xian/"/>
      <url>/2022/05/28/shu-de-qian-zhong-xu-bian-li-die-dai-fa-shi-xian/</url>
      
        <content type="html"><![CDATA[<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>相信大家看到这个博客一般都会知道如何通过递归的方式去遍历一棵树，但是通过迭代的方式往往写出前中后序遍历时比较恼火，最近看到一篇博客上写的比较好，所以就在这里分享一下：</p><h4 id="前序遍历迭代写法"><a href="#前序遍历迭代写法" class="headerlink" title="前序遍历迭代写法"></a>前序遍历迭代写法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token keyword">null</span><span class="token operator">||</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//从root节点一直往下走直到左子节点为空</span><span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>root<span class="token operator">=</span>root<span class="token punctuation">.</span>left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//此时取出左子节点为空的点，因为左子节点为空了，而且此时节点已经到了树最左边节点的最底部，因此需要换右侧节点开始继续遍历了</span><span class="token class-name">TreeNode</span> cur<span class="token operator">=</span>stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> root<span class="token operator">=</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="中序遍历迭代写法"><a href="#中序遍历迭代写法" class="headerlink" title="中序遍历迭代写法"></a>中序遍历迭代写法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token keyword">null</span><span class="token operator">||</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>root<span class="token operator">=</span>root<span class="token punctuation">.</span>left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">TreeNode</span> cur<span class="token operator">=</span>stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>root<span class="token operator">=</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出来其实中序遍历与前序遍历相比都是同样的不断往左子树走，实在走不动了再往右子树走，但考虑到我们遍历树时实际做的操作其实就是把树遍历的<code>value</code>写入到一个<code>list</code>中去而已，但是如果按照这种方式去写后序遍历迭代时，我们通过<code>stk</code>回退到上一层之后，这个节点就已经被栈<code>pop</code>掉了，按照后序遍历的定义需要遍历完右子树之后再回来把根的值写入到<code>list</code>中，但是此时如何去找右子树的根节点就是一个很麻烦的事。</p><p>但是可以通过另一种思路，后序遍历是左右根的顺序，可以先求出根右左的结果，然后把这个<code>list</code>反转一下就得出结果了，所以后序遍历的迭代写法如下：</p><h4 id="后序遍历迭代写法"><a href="#后序遍历迭代写法" class="headerlink" title="后序遍历迭代写法"></a>后序遍历迭代写法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token keyword">null</span><span class="token operator">||</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>root<span class="token operator">=</span>root<span class="token punctuation">.</span>right<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">TreeNode</span> cur<span class="token operator">=</span>stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>root<span class="token operator">=</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 - 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>检视阅读</title>
      <link href="/2022/05/14/jian-shi-yue-du/"/>
      <url>/2022/05/14/jian-shi-yue-du/</url>
      
        <content type="html"><![CDATA[<h3 id="阅读的第二层次"><a href="#阅读的第二层次" class="headerlink" title="阅读的第二层次"></a>阅读的第二层次</h3><hr><h4 id="检视阅读"><a href="#检视阅读" class="headerlink" title="检视阅读"></a>检视阅读</h4><p>检视阅读作为分析阅读的前一层次，首先可以让读者在进行分析阅读之前快速地了解这本书是否是我所需要分析阅读的书，对于一本只需要自己快速浏览类的书也就没必要花那么大的功夫去弄懂了，这一层次主要包括两个阶段</p><ol><li><p>有系统的略读</p><p> 下面是关于略读的一些建议</p><ul><li>先看书名页，如果有序的话就先看序</li><li>研究目录页</li><li>如果书中附有索引，得需要快速地看一眼</li><li>可以读一下作者的介绍</li><li>自己挑几个觉得与主题比较相关的篇章来看</li><li>把书打开随便翻一翻，连续读几页</li></ul></li><li><p>粗浅的阅读</p><p> 这部分最重要的就是遵循一个规则：<strong>头一次面对一本比较难读的书的时候，先从头到尾读一遍，遇到不懂的就跳过，直到遇到自己理解的部分再继续理解，遇到不懂的再跳过，就这样直到结束</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 如何阅读一本书 </tag>
            
            <tag> 检视阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析阅读</title>
      <link href="/2022/05/14/fen-xi-yue-du/"/>
      <url>/2022/05/14/fen-xi-yue-du/</url>
      
        <content type="html"><![CDATA[<h3 id="阅读的第三层次"><a href="#阅读的第三层次" class="headerlink" title="阅读的第三层次"></a>阅读的第三层次</h3><hr><h4 id="分析阅读"><a href="#分析阅读" class="headerlink" title="分析阅读"></a>分析阅读</h4><p>作为如何阅读一本书中作者最重点介绍的一个层次，也是我们所需要重点去学会的一种阅读层次，在这一层次上我们作为读者需要完成以下三个阶段</p><ol><li>找出一本书在谈论什么<ul><li>首先按照书的类型和主题进行分类</li><li>然后通过自己的语言用一段简短的话表述这本书在谈论什么</li><li>将书中的主要部分按照顺序和关联性列出一个大纲出来，对于每一部分也另外单独列一个大纲出来</li><li>可以通过前面这些的梳理得出一个初步的判断作者想要解决的问题</li></ul></li><li>诠释一本书的内容<ul><li>诠释作者的关键字并与他达成共识</li><li>通过最重要的句子来抓住这部分内容中作者的主旨是什么</li><li>知道作者的论述是什么，找出来之后再把它们组织到一起重新架构起来</li><li>确定哪些问题是作者已经解决的问题，而哪些问题是作者未解决的问题，而哪些又是作者自己知道自己并没有解决的问题</li></ul></li><li><p>像是沟通知识一样去评论一本书</p><ol><li><p>以下是礼节性的规则</p><ul><li>只有在自己已经完成了这本书的大纲或者已经能诠释整本书的内容了之后才能去进行这一步骤</li><li>不要争强好胜，非辩到底不可</li><li>说出评论之前得先分清楚真正的知识以及个人观点之间的差别</li></ul></li><li><p>以下是批评的标准</p><ul><li>证明作者知识的不足</li><li>证明作者知识的错误</li><li>证明作者不合逻辑</li><li>证明作者的分析和理由是不正确的</li></ul></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 如何阅读一本书 </tag>
            
            <tag> 分析阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见背包问题</title>
      <link href="/2022/05/04/chang-jian-bei-bao-wen-ti/"/>
      <url>/2022/05/04/chang-jian-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="常见背包问题"><a href="#常见背包问题" class="headerlink" title="常见背包问题"></a>常见背包问题</h3><h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><p>背包问题是给定<code>n</code>类物品，每类物品有一个价值<code>w</code>，想要将这<code>n</code>类物品放入体积为<code>v</code>的背包中，想要求出这个背包能够容纳的最大价值，对于这类问题如果想要dfs遍历所有的情况很可能会超时，而通过dp的状态表示可以大大降低搜索的次数，因为往往一个状态代表的是多种方案的结果，不需要重复遍历相同状态的方案</p><p>背包问题根据拿取物品的规则不同可以分为01背包，完全背包，分组背包，多重背包等等，目前比较常见的背包问题主要就是01背包和完全背包，因此本篇文章主要介绍这两种背包问题的解法</p><h4 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h4><p>拿取物品的规则是要么不拿，要么只能拿一个，通过闫氏dp法可以用一个二维状态来表示所有满足情况的集合，而状态值<code>f[i][j]</code>就是取前<code>i</code>类物品，总体积不超过<code>j</code>的最大价值</p><p>朴素做法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>v<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意到在空间上我们其实每次计算第<code>i+1</code>轮状态值时只用了上一轮的状态，因此可以考虑用轮转数组压缩空间，需要注意的是里层循环必须要从大到小遍历，这样可以保证每次的<code>f[j-v[i-1]]</code>是上一层的状态</p><p>轮转数组做法<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>m<span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>v<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><p>每个物品可以无限拿，求背包容纳的最大价值，状态值与01背包问题相同，问题就是状态转移的过程，但完全背包问题可以通过递推公式简化</p><p>$ f[i][j]=Math.max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v]+2w,…f[i-1][j-kv]+kw) \quad  kv&lt;=j$<br>$ f[i][j-v]=Math.max(f[i-1][j-v],f[i-1][j-2v]+w,f[i-1][j-3v]+2w+,,,f[i-1][j-kv]+(k-1)w) \quad kv&lt;=j$<br>从上述公式把第二个式子代入可以得出<br>$f[i][j]=Math.max(f[i-1][j],f[i][j-v]+w)$</p><p>这时候代码层面的处理其实就跟前面的01背包问题类似了</p><p>朴素做法<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>v<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>空间优化版<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>v<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包问题 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
